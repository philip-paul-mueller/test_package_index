name: Updates the Python package index upon an event. 

on:
  repository_dispatch:
    types: [update_package_index]
  workflow_dispatch:
    inputs:
      source_repo:
        description: 'Name of the repo that contains the dependency.'
        required: true
        type: string
      source_org:
        description: 'Name of the organization/user that owns the dependency repo.'
        required: true
        type: string
      dependency_ref:
        description: 'Reference that in the dependency repo that should be checked out and turned into a dependency.'
        required: true
        type: string

jobs:
  update-index:
    runs-on: ubuntu-latest
    steps:
      - name: Print all variables
        shell: bash
        run: |
          echo "source_repo: ${{ inputs.source_repo == '' && github.event.client_payload.source_repo || inputs.source_repo }}"
          echo "source_org:  ${{ inputs.source_org == '' && github.event.client_payload.source_org || inputs.source_org }}"
          echo "dep_ref:     ${{ inputs.dependency_ref == '' && github.event.client_payload.dependency_ref || inputs.dependency_ref }}"

      - name: Checkout the `master` branch of the Python package index.
        uses: actions/checkout@v4
        with:
          path: index_repo
          ref: master    # We always work on master!

      - name: Checkout the repo of the dependency that should be added to the index.
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.source_org == '' && github.event.client_payload.source_org || inputs.source_org }}/${{ inputs.source_repo == '' && github.event.client_payload.source_repo || inputs.source_repo }}
          path: ${{ inputs.source_repo == '' && github.event.client_payload.source_repo || inputs.source_repo }}
          submodules: 'recursive'
          ref: ${{ inputs.dependency_ref == '' && github.event.client_payload.dependency_ref || inputs.dependency_ref }}

      - name: Build the distribution file.
        shell: bash
        run: |
          DEPENDENCY_REPO="${PWD}/${{ inputs.source_repo == '' && github.event.client_payload.source_repo || inputs.source_repo }}"
          PACKAGE_BUILD_FOLDER="${PWD}/index_repo/build"

          cd "${DEPENDENCY_REPO}"
          python -m pip install build --user
          python -m build --wheel --outdir "${PACKAGE_BUILD_FOLDER}"

      - name: Test the distribution file.
        shell: bash
        run: |
          PACKAGE_BUILD_FOLDER="${PWD}/index_repo/build"
          DESTINATION_FOLDER="${PWD}/index_repo/${{ inputs.source_repo == '' && github.event.client_payload.source_repo || inputs.source_repo }}"
          mkdir -p "${DESTINATION_FOLDER}"

          readarray -t -d "" PACKAGE_FILES  < <(find "${PACKAGE_BUILD_FOLDER}" -type f -print0)
          for I in ${!PACKAGE_FILES[@]}
          do
            PACKAGE_FILE="${PACKAGE_FILES[$I]}"
            pip install --force-reinstall --upgrade --no-deps "${PACKAGE_FILE}"
            if [ $? -ne 0 ]
            then
              echo "Failed to install package '${PACKAGE_FILE}'"
              exit 3
            fi
            echo "Successfully tested '${PACKAGE_FILE}'"
            cp -t "${DESTINATION_FOLDER}" "${PACKAGE_FILE}"
          done

      - name: Rescan the package index and update the static `index.html` files.
        shell: bash
        env:
          CI_COMMIT_MESSAGE: updated dependency "${{ inputs.source_org == '' && github.event.client_payload.source_org || inputs.source_org }}/${{ inputs.source_repo == '' && github.event.client_payload.source_repo || inputs.source_repo }}"
          CI_COMMIT_AUTHOR: github-actions[bot]
          CI_COMMIT_EMAIL: username@users.noreply.github.com
        run: |
          cd ./index_repo

          # Not fully sure if this check is useful, because it seems that creating a wheel is not reproducible.
          #  I.e. creating a wheel from a commit and then generating another wheel will result in a "different",
          #  in terms of its hash, file than the first time.
          if ! git status --porcelain --untracked-files=no ; then
            # There are no changed.
            echo "There were no changes!"
            exit 0
          fi

          # Update all the packages.
          python generator.py

          # We directly push to master!
          git config --global user.name "${{ env.CI_COMMIT_AUTHOR }}"
          git config --global user.email "${{ env.CI_COMMIT_EMAIL }}"
          git add .
          git commit --no-verify -m "${CI_COMMIT_MESSAGE}"
          git push origin master
